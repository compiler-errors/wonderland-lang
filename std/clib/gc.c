#include "clib.h"
#include "statepoint.h"

const i16 MARK_FLAG = 1 << 15;

// {ptr} is a pointer to the value, not the value itself. Deref it, THEN cast to a (struct string*), etc.
// NOTE: This function is auto-generated by cheshire itself.
void gc_visit(i8* ptr, i16 ty);

i1 gc_mark(i8* val) {
  if (val == NULL) {
    printf("Tried to mark NULL\n");
    return true;
  }

  val -= sizeof(i16);
  i16 mark = *((i16*) val);

  // Is it already marked?
  if (MARK_FLAG & mark) {
    printf("Marking %p: Is marked.\n", val);
    return true;
  } else {
    *((i16*) val) = mark | MARK_FLAG;
    printf("Marking %p.\n", val);
    return false;
  }
}

void gc_visit_array(struct array* array, i16 element_ty) {
  if (array == NULL) {
    return;
  }

  if (gc_mark((i8*) array)) {
    return;
  }

  // TODO: lmao use a better iteration type.
  for (int i = 0; i < array->length; i++) {
    gc_visit(array->payload + i * array->element_size, element_ty);
  }
}

i16 gc_get_type(i8* val) {
  val -= sizeof(i16);
  i16 mark = *(i16*) val;
  return mark & ~MARK_FLAG;
}

// ----- ----- ----- ----- ----- ----- GC walking shit ----- ----- ----- ----- ----- ----- //

extern uint8_t __LLVM_StackMaps[] __attribute__ ((section(".llvm_stackmaps")));

statepoint_table_t* table;
bool table_built = false;

NOINLINE void gc(i8* cheshire_stack_root) {
    cheshire_stack_root += sizeof(void*);
    int64_t ret = *(int64_t*) cheshire_stack_root;
    cheshire_stack_root += sizeof(void*);

    if (!table_built) {
        printf("Building table!\n");

        table = generate_table((void*) &__LLVM_StackMaps, 0.5);

        printf("GC is invoked!\nprinting the table...\n");
        print_table(stdout, table, true);
        printf("\n");
        table_built = true;
    }

    frame_info_t* frame = lookup_return_address(table, ret);

    if (frame == NULL) {
        // TODO: Panic, first frame should never be NULL.
    }

    while (frame) {
        printf("Frame @ 0x%" PRIX64 " has %d slots\n", ret, frame->numSlots);

        for (int i = 0; i < frame->numSlots; i++) {
            pointer_slot_t ptrSlot = frame->slots[i];
            if(ptrSlot.kind >= 0) {
                // our example does not use derived pointers
                printf("unexpected derived pointer\n");
                exit(-1);
            }

            i8** stack_ptr = (i8**) (cheshire_stack_root + ptrSlot.offset);
            i16 type = gc_get_type(*stack_ptr);

            printf("Visiting %p (type = %"PRId16")\n", *stack_ptr, type);
            gc_visit((i8*) stack_ptr, type);
        }

        cheshire_stack_root += frame->frameSize;
        ret = *(int64_t*) cheshire_stack_root;
        cheshire_stack_root += sizeof(void*);

        frame = lookup_return_address(table, (int64_t) ret);
    }

    printf("End of frames!\n\n");
}

NOINLINE void fp2gc(void) {
  gc(__builtin_frame_address(0));
}